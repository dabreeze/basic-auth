package com.authentication.loan_mandate.service;import com.authentication.loan_mandate.data.LoanMandateGroupDto;import com.authentication.loan_mandate.data.ExcelPayloadRequest;import com.authentication.loan_mandate.domain.model.LoanMandate;import com.authentication.loan_mandate.domain.repository.LoanMandateRepository;import com.authentication.loan_mandate.utilHelper.ExcelHelper;import com.authentication.loan_mandate.utilHelper.MapperUtil;import com.authentication.loan_mandate.webClientApi.WebClientApi;import lombok.RequiredArgsConstructor;import org.json.JSONObject;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Value;import org.springframework.http.HttpStatus;import org.springframework.scheduling.annotation.EnableAsync;import org.springframework.stereotype.Service;import org.springframework.util.LinkedMultiValueMap;import org.springframework.util.MultiValueMap;import org.springframework.web.multipart.MultipartFile;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.time.LocalDateTime;import java.util.*;import java.util.concurrent.Executors;import java.util.concurrent.ScheduledExecutorService;import java.util.stream.Collectors;@EnableAsync@RequiredArgsConstructor@Servicepublic class MandateServiceImpl implements MandateService {    private final Logger Log = LoggerFactory.getLogger(MandateService.class);    private final MapperUtil mapperUtil;    private final ExcelHelper excelHelper;    private final LoanMandateRepository repository;    ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);    private final WebClientApi webClientApi;    private final ExcelPayloadRequest excelPayloadRequest = new ExcelPayloadRequest();    @Value("${nx360_loan_info.path}")    private String nx360LoanInfoUrl;    @Value("${nx_Wrapper.path}")    private String nxWrapper;    @Value("${middleWare_response_save.path}")    private String middleWareResponseSave;    @Value("${errorLog_from_middleWare_save.path}")    private String errorLogFromMiddleWareSave;    @Value("${nx360Token}")    private String nx360Token;    @Value("${nxWrapperToken}")    private String nxWrapperToken;    private static final LoanMandate mandate = new LoanMandate();    public MultiValueMap<String, String> addedHeaderFun() {        MultiValueMap<String, String> addedHeader = new LinkedMultiValueMap<>();        addedHeader.add("Fineract-Platform-TenantId", "default");        addedHeader.add("Authorization", "Basic " + nx360Token);        return addedHeader;    }    @Override    public JSONObject generateMandate() {        JSONObject response = new JSONObject();        List<Integer> statusValue = new ArrayList<>();        statusValue.add(0);        statusValue.add(3);        List<LoanMandate> loanMandateList = repository.findByStatusIn(statusValue);        if (!loanMandateList.isEmpty()) {            response.put("message", "Data sent to remita");            for (LoanMandate aMandate : loanMandateList) {                Log.info("single mandate {}", aMandate);                try {                    JSONObject mandate = generateSingleLoanMandate(aMandate);                } catch (Exception e) {//                LoanMandate newResponse = new LoanMandate();                    String error = e.toString();                    aMandate.setMessage(error);                    aMandate.setStatus(3);                    repository.save(aMandate);                    Log.error("--------> entered catch " + e);                }            }        } else {            response.put("message", "No Data available");        }        Log.info("response 1{}", response);//        response.put("")        return response;    }    //    @Scheduled(fixedDelay = 23, timeUnit = TimeUnit.HOURS)//    @Scheduled(fixedDelay = 3, timeUnit = TimeUnit.MINUTES)//    @Async//    @Scheduled(fixedDelay = 10000)    public void chronJob() {        Log.info("\nCron job started\n");        generateMandate();        Log.info("\nCron job stopped\n");    }    private JSONObject generateSingleLoanMandate(LoanMandate aMandate) {//        LoanMandate mandate = null;        JSONObject response = new JSONObject();        JSONObject debitedMandate = callNxWrapper(aMandate);//        Log.info("--------> response from middleWare" + debitedMandate);//          MiddleWare        boolean status = debitedMandate.getBoolean("status");        if (status) {            String messageResult = debitedMandate.getString("message");            String mandateReference = debitedMandate.getJSONObject("data").getString("mandateReference");            Log.info("updating status: ");            aMandate.setMessage(messageResult);            aMandate.setStatus(1);            aMandate.setMandateReference(mandateReference);            repository.save(aMandate);            response.put("status", true);            response.put("message", aMandate.getMessage());            response.put("mandateReference", mandateReference);        } else {            JSONObject remitaResponse = debitedMandate.getJSONObject("data").getJSONObject("remitaResponse");//            String message = debitedMandate.getJSONObject("data").getJSONObject("remitaResponse").getString("message");            String message = debitedMandate.getString("message");            if (remitaResponse != null) {                Log.info("Entered first else");                aMandate.setMessage(message);                aMandate.setStatus(2);            } else {                Log.info("Entered second else");                aMandate.setMessage(message);                aMandate.setStatus(3);            }            repository.save(aMandate);            response.put("status", false);            response.put("message", message);        }        Log.info("response 2 {}", response);        return response;    }    @Override    public List<LoanMandate> exportLoansToExcelFormat(HttpServletResponse response) throws IOException {        List<LoanMandate> loanMandateList = repository.findAll();        ExcelHelper excelHelper1 = new ExcelHelper(loanMandateList);        excelHelper.exportDataToExcel(response);        return loanMandateList;    }    @Override    public Map<String, String> uploadExcelMandateSchedule(MultipartFile file) throws IOException {        Log.info("----------> Service started {}", file.getInputStream().read());        Map<String, String> response = new HashMap<>();        try {            List<ExcelPayloadRequest> excelPayloadRequestList = excelHelper.readExcelToDatabase(file.getInputStream());            Log.info("--------> converted file " + excelPayloadRequestList.toString());            for (ExcelPayloadRequest loan : excelPayloadRequestList) {                LoanMandate mandate = mapperUtil.mapExcelPayloadToLoan(loan);                LoanMandate savedLoanMandate = repository.save(mandate);                response.put("status", HttpStatus.ACCEPTED.toString());                response.put("batchNumber", savedLoanMandate.getBatchNumber());                response.put("date", savedLoanMandate.getStartDate());                response.put("message", "Uploaded successfully");                Log.info("-------> Saved Loan mandate {}", savedLoanMandate);            }            Log.info("-------> Generate mandate started ");            generateMandate();        } catch (Exception e) {            Log.error("Error from catch comes here {}  ", e.getMessage());            throw new NullPointerException(e.getLocalizedMessage());        }        Log.info("response 3{}", response);        return response;    }    private JSONObject callNxWrapper(LoanMandate loanMandate) {// handle exception if allex fails        Log.info("payload going in Nxwrapper {}", loanMandate);        MultiValueMap<String, String> addedHeader2 = new LinkedMultiValueMap<>();        addedHeader2.add("Authorization", "Bearer " + nxWrapperToken);        Log.info("---------> Calling NxWrapper ");        Log.info("---------> Loan mandate {} ", loanMandate);        JSONObject generateMandateFromNxWrapper = webClientApi.postWebClient(nxWrapper + "/Channels/GenerateMandate",                addedHeader2, mapperUtil.mapLoanToPayloadToMiddleWare(loanMandate)).block();        assert generateMandateFromNxWrapper != null;        return generateMandateFromNxWrapper.getJSONObject("data");    }    private void logErrorToNx360(JSONObject object) {        Log.info("---------> Calling Nx360 to log response ");        JSONObject response = webClientApi.postWebClient(nxWrapper + "/Channels/GenerateMandate",                addedHeaderFun(), object).block();        Log.info("---------> Response logged to NX360 {}", response);    }    @Override    public List<LoanMandateGroupDto> generateGroupReportForLoanMandate() {        LocalDateTime today = LocalDateTime.now();        return repository.findAllGroupedLoanMandate();//        List<LoanMandate> allLoansWithBatchNumber = repository.findAll();//        List<LoanMandate> dataTillDate = repository.findByStartDateLessThanEqual(String.valueOf(today));//////        repository.f////        if (!(startDate.isBlank() && endDate.isBlank())) {//            List<LoanMandate> loanMandateList = dataTillDate.stream()//                    .filter(date -> date.getStartDate().equals(startDate))//                    .filter(date -> date.getEndDate().equals(endDate))//                    .collect(Collectors.toList());//            if (status != null) {//                List<LoanMandate> loanWithStatus = loanMandateList.stream()//                        .filter(e -> e.getStatus().equals(status))//                        .collect(Collectors.toList());//                return loanWithStatus;//            } else if (endDate !=null) {//                List<LoanMandate> loanWithStatus = loanMandateList.stream()//                        .filter(e -> e.getEndDate().equals(endDate))//                        .collect(Collectors.toList());//                return loanWithStatus;////            } else if (startDate != null) {//                List<LoanMandate> loanWithStatus = loanMandateList.stream()//                        .filter(e -> e.getStartDate().equals(startDate))//                        .collect(Collectors.toList());//                return loanWithStatus;//            }////            return loanMandateList;////        } else {//            return dataTillDate;//        }    }    @Override    public List<LoanMandate> generateReportForLoanMandate(String startDate, String endDate, String batchNumber, Integer status) {        return repository.findAllLoanMandate(startDate,endDate,batchNumber,status);    }//    @Override//    public List<LoanMandateGroupDto> generateReportForLoanMandate(String startDate, String endDate, String batchNumber, Integer status) {//        LocalDateTime today = LocalDateTime.now();////        return repository.findAllLoanMandate();////        List<LoanMandate> allLoansWithBatchNumber = repository.findAll();//        List<LoanMandate> dataTillDate = repository.findByStartDateLessThanEqual(String.valueOf(today));//////        repository.f////        if (!(startDate.isBlank() && endDate.isBlank())) {//            List<LoanMandate> loanMandateList = dataTillDate.stream()//                    .filter(date -> date.getStartDate().equals(startDate))//                    .filter(date -> date.getEndDate().equals(endDate))//                    .collect(Collectors.toList());//            if (status != null) {//                List<LoanMandate> loanWithStatus = loanMandateList.stream()//                        .filter(e -> e.getStatus().equals(status))//                        .collect(Collectors.toList());//                return loanWithStatus;//            } else if (endDate != null) {//                List<LoanMandate> loanWithStatus = loanMandateList.stream()//                        .filter(e -> e.getEndDate().equals(endDate))//                        .collect(Collectors.toList());//                return loanWithStatus;////            } else if (startDate != null) {//                List<LoanMandate> loanWithStatus = loanMandateList.stream()//                        .filter(e -> e.getStartDate().equals(startDate))//                        .collect(Collectors.toList());//                return loanWithStatus;//            }////            return loanMandateList;//        }//    }    private List<LoanMandate>getLoanMandate(String batchnumber){        return repository.findAll().stream().filter(e->e.getBatchNumber().equals(batchnumber))                .collect(Collectors.toList());    }}